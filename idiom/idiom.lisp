(defparameter *idiom* (make-hash-table))
(defparameter *head* (make-hash-table))
(defparameter *num* 0)

(with-open-file (idiom "idiom.csv" :direction :input)
  (do ((word (read-line idiom nil 'eof)
	     (read-line idiom nil 'eof)))
      ((eql word 'eof))
    (push word (gethash (char word 0) *head*))
    (setf (gethash word *idiom*) t)
    (incf *num*)))

(defun random-idiom ()
  (let ((num (random *num*))
	(word)
	(i 0))
    (maphash #'(lambda (key value)
		 (when (= i num)
		   (setf word key))
		 (incf i))
	     *idiom*)
    word))

(defun make-queue (nodes path)
  (let* ((queue) (tail))
    (dolist (node nodes (values queue tail))
      (push (cons node path) queue)
      (when (null tail)
	(setf tail queue)))))

(defun nappend-queue (queue1 queue1-tail queue2 queue2-tail)
  (setf (cdr queue1-tail) queue2)
  (values queue1 queue2-tail))

(defun idiom-solitaire (start end)
  (format t "start = ~A; end = ~A~%" start end)
  (let ((usedwords (make-hash-table)))
    (gethash start usedwords)
    (labels ((filter-word (words)
	       (member-if #'(lambda (word)
			      (not (gethash word usedwords)))
			  words))
	     (insert-usedwords (words)
	       (dolist (word words)
		 (setf (gethash word usedwords) t)))
	     (last-char (word)
	       (char (reverse word) 0))
	     (get-next-words (word)
	       (let ((next-words (filter-word (gethash (last-char word) *head*))))
		 (insert-usedwords next-words)
		 next-words))
	     (rec (queue tail)
	       (if (null queue)
		   nil
		   (let* ((path (car queue))
			  (word (car path)))
		     (if (string-equal word end)
			 (reverse path)
		         (let ((next-words (get-next-words word)))
			   (if next-words
			       (multiple-value-bind (next-queue next-tail)
				   (make-queue next-words path)
				 (multiple-value-bind (new-queue new-tail)
				     (nappend-queue queue tail next-queue next-tail)
				   (rec (cdr new-queue) new-tail)))
			       (rec (cdr queue) tail))))))))
      (let* ((queue (list (list start))))
	(rec queue queue)))))
